package com.osm2xp.translators.airfield;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

import org.apache.commons.lang.StringUtils;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.operation.buffer.BufferOp;
import org.locationtech.jts.operation.buffer.BufferParameters;
import org.locationtech.jts.operation.union.CascadedPolygonUnion;

import com.osm2xp.core.constants.CoreConstants;
import com.osm2xp.core.logging.Osm2xpLogger;
import com.osm2xp.generation.options.XPlaneOptionsProvider;
import com.osm2xp.model.osm.polygon.OsmPolygon;
import com.osm2xp.utils.geometry.GeomUtils;
import com.osm2xp.utils.osm.OsmUtils;

import math.geom2d.Point2D;
import math.geom2d.polygon.LinearCurve2D;
import math.geom2d.polygon.LinearRing2D;

/**
 * Airport data writer for X-Plane Based on apt.dat 10.50 spec -
 * <a>http://developer.x-plane.com/wp-content/uploads/2017/02/XP-APT1050-Spec.pdf</a>
 * 
 * @author Dmitry Karpenko
 *
 */
public class XPAirfieldOutput {
	
//	public static final String wktMollweide = "PROJCS[\"World_Mollweide\"," +
//            "GEOGCS[\"WGS_1984\",DATUM[\"WGS_1984\",SPHEROID[\"WGS_1984\",6378137.0,298.257223563]]," +
//            "PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Mollweide\"]," +
//            "PARAMETER[\"Central_Meridian\",0.0],UNIT[\"Meter\",1.0]]";
//
//
//    public static final String wktEckert = "PROJCS[\"World_Eckert_IV\"," +
//            "GEOGCS[\"WGS_1984\",DATUM[\"WGS_1984\",SPHEROID[\"WGS_1984\",6378137.0,298.257223563]],"+
//            "PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Eckert_IV\"]," +
//            "PARAMETER[\"Central_Meridian\",0.0],UNIT[\"Meter\",1.0]]";

	private static final String NAV_DATA_FOLDER_NAME = "Earth nav data";
	private static final String OSM2XP_AIRFIELD_PREFFIX = "osm2xp_";
	private static final double METER_TO_FEET_COEF = 3.28084;
	private File baseFolder;
	private boolean writeMainAirfield;
	private int fakeICAOIdx = 0;

	public XPAirfieldOutput(File baseFolder, boolean writeMainAirfield) {
		this.baseFolder = baseFolder;
		this.writeMainAirfield = writeMainAirfield;
		baseFolder.mkdirs();
	}

	public List<String> getAptHeaderString() {
		List<String> result = new ArrayList<String>();
		result.add("I");
		result.add("1000 Version - generated by OSM2XP " + CoreConstants.OSM2XP_VERSION);
		result.add("");
		return result;
	}

	public void writeAirfield(AirfieldData airfieldData) {
		List<RunwayData> runways = airfieldData.getUniqueRunways();
		List<HelipadData> helipads = airfieldData.getHelipads();
		if (runways.isEmpty() && helipads.isEmpty()) {
			return; // Do nothing, if no runways/helipads assigned for airport
		}
		List<String> defsList = new ArrayList<String>();
		defsList.addAll(getAptHeaderString());
		String icao = checkGetICAO(airfieldData);
		defsList.add(String.format(Locale.ROOT, "1 %d 0 0 %s %s", (int) Math.round(airfieldData.getElevation() * METER_TO_FEET_COEF),
				icao, airfieldData.getLabel()));
		if (shouldFlatten(airfieldData)) {
			defsList.add("1302 flatten 1");
		}
		Point2D datum = airfieldData.getDatum();
		defsList.add(String.format(Locale.ROOT, "1302 datum_lat %1.6f", datum.y()));
		defsList.add(String.format(Locale.ROOT, "1302 datum_lon %1.6f", datum.x()));
		for (RunwayData runway : runways) {
			defsList.add(getRunwayStr(runway));
		}
		for (int i = 0; i < helipads.size(); i++) {
			defsList.add(getHelipadStr(helipads.get(i), i, airfieldData));
		}
		defsList.addAll(getApronDefs(airfieldData));
		if (airfieldData instanceof PolyAirfieldData) {
			LinearRing2D polygon = ((PolyAirfieldData) airfieldData).getPolygon();
			if (polygon != null && polygon.vertexNumber() > 3) {
				defsList.addAll(getAptAreaDef(icao, airfieldData));
			}
		}
		defsList.add("99");
		writeAptData(airfieldData.getId(), defsList.toArray(new String[0]));
	}

	private String getHelipadStr(HelipadData helipadData, int idx, AirfieldData airfieldData) {
		StringBuilder builder = new StringBuilder("102 ");
		builder.append("H");
		builder.append(idx + 1);
		builder.append(String.format(Locale.ROOT, " %1.8f %2.8f ", helipadData.getLat(), helipadData.getLon()));
		double heading = helipadData.getHeading();
		if (heading >= 0) {
			builder.append(String.format(Locale.ROOT, "%1.2f", heading));
		} else {
			builder.append(getOrientation(airfieldData));
		}
		builder.append(" ");
		builder.append(String.format(Locale.ROOT, "%1.2f",helipadData.getLength()));
		builder.append(" ");
		builder.append(String.format(Locale.ROOT, "%1.2f",helipadData.getWidth()));
		builder.append(" ");
		builder.append(airfieldData.isHard() ? "1" : "3");
		builder.append(" 0 0 ");
		builder.append(airfieldData.isHard() ? "0.2" : "0.3");
		builder.append(" ");
		builder.append(airfieldData.isHard() ? "1" : "0");
		return builder.toString();
	}

	private List<? extends String> getApronDefs(AirfieldData airfieldData) {
		List<String> list = new ArrayList<String>();
		try {
			Point2D centerPoint = airfieldData.getAreaCenter();
			List<OsmPolygon> apronAreas = airfieldData.getApronAreas();
			List<TaxiLane> taxiLanes = airfieldData.getTaxiLanes();
			List<Geometry> convertedAreas = apronAreas.stream()
					.map(polyline -> GeomUtils.geom2dToJtsLocal(polyline.getPolyline(), centerPoint))
					.collect(Collectors.toList());
			double taxiwayWidth = airfieldData.isHard()
					? XPlaneOptionsProvider.getOptions().getAirfieldOptions().getDefaultHardTaxiwayWidth()
							: XPlaneOptionsProvider.getOptions().getAirfieldOptions().getDefaultGrassTaxiwayWidth();
			double dist = taxiwayWidth / 2.0 / 111000;
//			String code = "AUTO:42001," + centerPoint.getX() + "," + centerPoint.getY();
//		    CoordinateReferenceSystem auto = CRS.decode(code);
//		    CoordinateReferenceSystem auto = CRS.decode(wktMollweide);

//		      MathTransform transform = CRS.findMathTransform(DefaultGeographicCRS.WGS84, DefaultGeocentricCRS.CARTESIAN);
//		      JTS.transform()
			BufferParameters bufferParameters = new BufferParameters(2, BufferParameters.CAP_ROUND);
			bufferParameters.setJoinStyle(BufferParameters.JOIN_MITRE);
			bufferParameters.setMitreLimit(1);
			List<Geometry> bufferedLanes = taxiLanes.stream()
					.map(lane -> buildBufferedLine(lane, bufferParameters, dist, centerPoint))
					.collect(Collectors.toList());
			List<Geometry> toJoin = new ArrayList<Geometry>(convertedAreas);
			toJoin.addAll(bufferedLanes);
			if (toJoin.size() > 0) {
				Geometry joinResult;
				if (toJoin.size() == 1) {
					joinResult = toJoin.get(0);
				} else {
					CascadedPolygonUnion op = new CascadedPolygonUnion(toJoin);
					joinResult = GeomUtils.fix(op.union());
				}
				List<Polygon> apronPolys = GeomUtils.flatMapToPoly(joinResult);
				for (Polygon polygon : apronPolys) {
					list.addAll(getApronDef(airfieldData, polygon, centerPoint));
				}
			}
			if (airfieldData.isHard() && XPlaneOptionsProvider.getOptions().getAirfieldOptions().isGenerateMarks()) {
				for (int j = 0; j < taxiLanes.size(); j++) {
					list.addAll(getTaxilaneDef(taxiLanes.get(j), j));
				}
			}
		} catch (Exception e) {
			Osm2xpLogger.error("Error creating apron area for " + airfieldData.getId() + " airfield");
		}
		return list;
	}

	protected Geometry buildBufferedLine(double dist, BufferParameters bufferParameters, Geometry lane) {
		Geometry buffered = BufferOp.bufferOp(lane, dist, bufferParameters);
		return buffered;
	}
	
	protected Geometry buildBufferedLine(TaxiLane lane, BufferParameters bufferParameters, double defaultWidth, Point2D centerPoint) {
		Geometry geom = GeomUtils.geom2dToJtsLocal(lane.getLine(), centerPoint);
		double dist = lane.getWidth() > 0 ? lane.getWidth() : defaultWidth; 
		Geometry buffered = BufferOp.bufferOp(geom, dist, bufferParameters);
		return buffered;
	}

	private List<String> getAptAreaDef(String icao, AirfieldData airfieldData) {
		List<String> resList = new ArrayList<String>();
		resList.add("130 " + icao);
		resList.addAll(getAreaString(((PolyAirfieldData) airfieldData).getPolygon()));
		return resList;
	}

	protected boolean shouldFlatten(AirfieldData airfieldData) {
		// If we have no actual elevation - flattening would goof up airfield,
		// making it a giant pit with bottom plateu having elevation 0m
		// Elevation will be taken from 'ele' tag in OSM if present.
		// If not, we'll try to obtain it via REST call, if it's allowed and we are
		// online.
		return XPlaneOptionsProvider.getOptions().getAirfieldOptions().isFlatten() && airfieldData.hasActualElevation();
	}

	private List<String> getTaxilaneDef(TaxiLane taxiLane, int index) {
		List<String> resList = new ArrayList<String>();
		resList.add("120 Taxiway " + index);
		Point2D[] points = taxiLane.getLine().vertexArray();
		for (int i = 0; i < points.length; i++) {
			if (i < points.length - 1) {
				resList.add(String.format(Locale.ROOT, "111 %1.8f %2.8f 1", points[i].y(), points[i].x()));
			} else {
				resList.add(String.format(Locale.ROOT, "115 %1.8f %2.8f", points[i].y(), points[i].x()));
			}
		}
		return resList;
	}

	private List<String> getApronDef(AirfieldData airfieldData, Polygon polygon, Point2D centerPoint) {
		List<String> resList = new ArrayList<String>();
		String surface = airfieldData.isHard() ? "2" : "3";
		String roughness = airfieldData.isHard() ? "0.2" : "0.3";
		resList.add("110 " + surface + " " + roughness + " " + getOrientation(airfieldData) + " Sample");
		resList.addAll(getAreaString(
				getRing(GeomUtils.jtsToGeom2dLocal(GeomUtils.setCCW(polygon.getExteriorRing()), centerPoint))));
		for (int i = 0; i < polygon.getNumInteriorRing(); i++) {
			resList.addAll(getAreaString(
				getRing(GeomUtils.jtsToGeom2dLocal(GeomUtils.setCW(polygon.getInteriorRingN(i)), centerPoint))));
		}
		return resList;
	}

	private LinearRing2D getRing(LinearCurve2D line) {
		if (line instanceof LinearRing2D) {
			return (LinearRing2D) line;
		}
		return new LinearRing2D(line.vertexArray());
	}

	private String getOrientation(AirfieldData airfieldData) {
		RunwayData longest = airfieldData.getLongestRunway();
		if (longest != null) {
			return String.format(Locale.ROOT, "%1.2f", longest.getTrueCourse());
		}
		return "0.00";
	}

	private List<String> getAreaString(LinearCurve2D polyline2d) {
		List<String> resList = new ArrayList<String>();
		int n = polyline2d.vertexNumber();
		if (n < 3) {
			return Collections.emptyList();
		}
		if (polyline2d.vertex(0).equals(polyline2d.vertex(n - 1))) {
			n--;
		}
		for (int i = 0; i < n; i++) {
			Point2D coords = polyline2d.vertex(i);
			if (i < n - 1) {
				resList.add(String.format(Locale.ROOT, "111 %1.8f %2.8f", coords.y(), coords.x()));
			} else {
				resList.add(String.format(Locale.ROOT, "113 %1.8f %2.8f", coords.y(), coords.x()));
			}
		}
		return resList;
	}

	protected String checkGetICAO(AirfieldData airfieldData) {
		String icao = airfieldData.getICAO();
		if (icao == null) {
			icao = "xx" + StringUtils.leftPad("" + getNextICAOIdx(), 2, '0');
		}
		return icao;
	}

	protected String checkGetICAO(RunwayData runwayData) {
		String name = runwayData.getName();
		if (OsmUtils.isValidICAO(name)) {
			return name.toUpperCase().trim();
		}
		String ref = runwayData.getRef();
		if (OsmUtils.isValidICAO(ref)) {
			return ref.toUpperCase().trim();
		}
		return "xx" + StringUtils.leftPad("" + getNextICAOIdx(), 2, '0');
	}

	private int getNextICAOIdx() {
		return fakeICAOIdx++;
	}

	public void writeSingleRunway(RunwayData runwayData) {
		List<String> defsList = new ArrayList<String>();
		defsList.addAll(getAptHeaderString());
		defsList.add(String.format(Locale.ROOT, "1 %d 0 0 %s %s", (int) Math.round(runwayData.getElevation() * METER_TO_FEET_COEF),
				checkGetICAO(runwayData), runwayData.getLabel()));
		defsList.add(getRunwayStr(runwayData));
		defsList.add("99");
		writeAptData(runwayData.getId(), defsList.toArray(new String[0]));
	}

	protected void writeAptData(String aptId, String[] aptDefinition) {
		if (aptDefinition.length == 0) {
			return;
		}
		File dataFolder;
		if (writeMainAirfield) {
			dataFolder = new File(baseFolder, NAV_DATA_FOLDER_NAME);
		} else {
			String folderName = aptId.replace('/','_');
			File airfieldFolder = new File(baseFolder, OSM2XP_AIRFIELD_PREFFIX + folderName);
			for (int i = 0; airfieldFolder.exists() && i < Integer.MAX_VALUE; i++) {
				airfieldFolder = new File(baseFolder, OSM2XP_AIRFIELD_PREFFIX + folderName + i);
			}
			dataFolder = new File(airfieldFolder, NAV_DATA_FOLDER_NAME);
		}
		dataFolder.mkdirs();
		try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(new File(dataFolder, "apt.dat").toPath(),  StandardCharsets.UTF_8))) {
			for (String string : aptDefinition) {
				writer.println(string);
			}
		} catch (IOException e) {
			Osm2xpLogger.error("Error saving apt.dat for airfield " + aptId);
		}
	}

	private String getRunwayStr(RunwayData runway) {
		StringBuilder builder = new StringBuilder("100 ");
		builder.append(String.format(Locale.ROOT, "%1.2f", runway.getWidth()));
		builder.append(' ');
		builder.append(getSurfaceCode(runway));
		builder.append(' ');
		builder.append(getSurfaceShoulderCode(runway));
		builder.append(' ');
		builder.append(getRoughness(runway));
		builder.append(' ');
		builder.append(getCenterLights(runway));
		builder.append(' ');
		builder.append(getEdgeLights(runway));
		builder.append(' ');
		builder.append(getDistSigns(runway));
		builder.append(' ');
		builder.append(getEndStr(runway.getMarking1(), runway.getRunwayLine().p1, runway.isHard()));
		builder.append(' ');
		builder.append(getEndStr(runway.getMarking2(), runway.getRunwayLine().p2, runway.isHard()));
		builder.append(' ');
		builder.append("# length " + runway.getLength() + "m");		
		return builder.toString();
	}

	private String getEndStr(String marking, Point2D coords, boolean isHard) {
		StringBuilder builder = new StringBuilder(marking);
		builder.append(' ');
		builder.append(String.format(Locale.ROOT, "%1.8f %2.8f 0 0 ", coords.y(), coords.x()));
		builder.append(' ');
		builder.append(getRunwayMarkingCode(isHard));
		builder.append(' ');
		builder.append(getApproachLightingCode(isHard));
		builder.append(' ');
		builder.append(getTGZLightingCode(isHard));
		builder.append(' ');
		builder.append(getREILCode(isHard));
		return builder.toString();
	}

	private int getRunwayMarkingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}

	private int getTGZLightingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}

	private int getREILCode(boolean isHard) {
		return isHard ? 1 : 0;
	}

	private int getApproachLightingCode(boolean isHard) {
		return isHard ? 1 : 0;
	}

	private int getDistSigns(RunwayData runway) {
		return runway.isHard() ? 1 : 0;
	}

	private int getCenterLights(RunwayData runway) {
		return runway.isHard() ? 1 : 0;
	}

	private int getEdgeLights(RunwayData runway) {
		return runway.isHard() ? 2 : 0;
	}

	private String getRoughness(RunwayData runway) {
		if (runway.isHard()) {
			return "0.15";
		}
		return "0.25";
	}

	private int getSurfaceShoulderCode(RunwayData runwayData) {
		if (!runwayData.isHard())
			return 0;
		String osmSurfaceType = runwayData.getSurface();
		if ("asphalt".equals(osmSurfaceType))
			return 1;
		if ("concrete".equals(osmSurfaceType) || "paved".equals(osmSurfaceType))
			return 2;
		return 0;
	}

	private int getSurfaceCode(RunwayData runwayData) {
		String osmSurfaceType = runwayData.getSurface();
		if ("asphalt".equals(osmSurfaceType))
			return 1;
		if ("concrete".equals(osmSurfaceType) || "paved".equals(osmSurfaceType))
			return 2;
		if ("earth".equals(osmSurfaceType) || "dirt".equals(osmSurfaceType) || "mud".equals(osmSurfaceType)
				|| "sand".equals(osmSurfaceType)) {
			return 4;
		}
		if ("gravel".equals(osmSurfaceType) || "fine_gravel".equals(osmSurfaceType)) {
			return 5;
		}
		return 3; // grass by default
	}

}
